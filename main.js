// Generated by CoffeeScript 1.12.4
(function() {
  var d, result, start;

  d = document;

  result = d.getElementById('result');

  console.log = function(line) {
    return result.value += line + '\n';
  };

  start = d.getElementById('start');

  start.addEventListener('click', function() {
    var a, b, chordMet, drawChart, e, f, fDeriv, funStr, getDataArray, getSegments, halfDiv, ind, j, len, m, match, modNewtMet, newtMet, parsedF, parsedFun, print, printFinal, reg, segment, segments, step;
    result.value = '';
    funStr = (d.getElementById('equation')).value || "x^3-3x^2-x+4";
    a = parseFloat((d.getElementById('a')).value || -2);
    b = parseFloat((d.getElementById('b')).value || 3);
    step = parseFloat((d.getElementById('step')).value || 0.5);
    e = parseFloat((d.getElementById('e')).value || 0.01);
    reg = /([+-]?\d*)[a-z](?:\^([+-]?\d+))?/g;
    funStr = funStr.split(' ').join('');
    parsedFun = (function() {
      var results1;
      results1 = [];
      while (match = reg.exec(funStr)) {
        results1.push([parseFloat(match[1]) || parseFloat(match[1] + 1), parseFloat(match[2]) || 1]);
      }
      return results1;
    })();
    reg = /($|[+-]\d*)(?:$|[+-])/;
    match = reg.exec(funStr);
    (m = match[1]) && parsedFun.push([parseFloat(m), 0]);
    parsedFun.sort(function(a, b) {
      return a[1] - b[1];
    });
    parsedF = [];
    f = function(x, parsedF, pow) {
      var el, j, len, sum;
      if (parsedF == null) {
        parsedF = parsedFun;
      }
      sum = 0;
      for (j = 0, len = parsedF.length; j < len; j++) {
        el = parsedF[j];
        sum += el[0] * Math.pow(x, el[1]);
      }
      if (pow != null) {
        return Math.pow(sum, pow);
      } else {
        return sum;
      }
    };
    fDeriv = function(x, rate, parsedF) {
      var el, i, j, k, len, ref, sum, t;
      if (parsedF == null) {
        parsedF = parsedFun;
      }
      sum = 0;
      for (j = 0, len = parsedF.length; j < len; j++) {
        el = parsedF[j];
        t = 1;
        if (el[1] < rate) {
          continue;
        }
        for (i = k = 0, ref = rate; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
          t *= el[1] - i;
        }
        sum += el[0] * t * Math.pow(x, el[1] - rate);
      }
      return sum;
    };
    getSegments = function() {
      var i, j, next, prev, ref, ref1, ref2, segments;
      segments = [];
      prev = 0;
      for (i = j = ref = a, ref1 = b, ref2 = step; ref2 > 0 ? j <= ref1 : j >= ref1; i = j += ref2) {
        if ((next = f(i)) === 0) {
          segments.push([i]);
        } else {
          if (prev * next < 0) {
            segments.push([i - step, i]);
          }
        }
        prev = next;
      }
      return segments;
    };
    halfDiv = function(a, b) {
      var c, fa, fb, fc, results1;
      results1 = [];
      while ((Math.abs(a - b)) > e) {
        fa = f(a);
        fb = f(b);
        c = (a + b) / 2;
        fc = f(c);
        if (fa * fc < 0) {
          b = c;
        } else {
          a = c;
        }
        results1.push([c]);
      }
      return results1;
    };
    chordMet = function(a, b) {
      var c, fa, fb, fc, fx0, ref, ref1, results, results1, x0;
      fa = f(a);
      fb = f(b);
      c = (a * fb - b * fa) / (fb - fa);
      fc = f(c);
      if (fa * fc < 0) {
        ref = [a, fa], x0 = ref[0], fx0 = ref[1];
      } else {
        ref1 = [b, f(b)], x0 = ref1[0], fx0 = ref1[1];
      }
      results = [];
      results1 = [];
      while ((Math.abs(fc)) > e) {
        c = (x0 * fc - c * fx0) / (fc - fx0);
        fc = f(c);
        results1.push([c]);
      }
      return results1;
    };
    newtMet = function(a, b) {
      var fa, results1, x, x0;
      fa = f(a);
      if ((fa * fDeriv(a, 2)) > 0) {
        x = a;
      } else {
        x = b;
      }
      x0 = 2e308;
      results1 = [];
      while ((Math.abs(x - x0)) > e) {
        x0 = x;
        results1.push([x = x - (f(x)) / fDeriv(x, 1)]);
      }
      return results1;
    };
    modNewtMet = function(a, b) {
      var dfx0, fa, fb, fx0, ref, ref1, results1, x, x0;
      fa = f(a);
      fb = f(b);
      if ((fa * fDeriv(a, 2)) > 0) {
        ref = [a, fa], x = ref[0], fx0 = ref[1];
      } else {
        ref1 = [b, fb], x = ref1[0], fx0 = ref1[1];
      }
      x0 = 2e308;
      dfx0 = fDeriv(x, 1);
      results1 = [];
      while ((Math.abs(x - x0)) > e) {
        x0 = x;
        results1.push([x = x - (f(x)) / dfx0]);
      }
      return results1;
    };
    print = function(name, arr) {
      var el, ind, j, len, results1;
      console.log(name);
      if ((arr == null) || arr.length === 0) {
        console.log("\tdiverged!!!");
        return;
      }
      results1 = [];
      for (ind = j = 0, len = arr.length; j < len; ind = ++j) {
        el = arr[ind];
        if (el.length === 2) {
          results1.push(console.log("\t" + (ind + 1) + ". [" + (el[0].toFixed(4)) + " ; " + (el[1].toFixed(4)) + "]"));
        } else {
          results1.push(console.log("\t" + (ind + 1) + ". " + (el[0].toFixed(4))));
        }
      }
      return results1;
    };
    printFinal = function(name, arr) {
      console.log("\t" + name);
      if ((arr == null) || arr.length === 0) {
        console.log("\tdiverged!!!");
        return;
      }
      return console.log("\t" + (arr[arr.length - 1][0].toFixed(4)));
    };
    segments = getSegments();
    if (!segments.length) {
      console.log("no roots");
      return;
    }
    print("Segments with root", segments);
    for (ind = j = 0, len = segments.length; j < len; ind = ++j) {
      segment = segments[ind];
      if (segment.length < 2) {
        continue;
      }
      a = segment[0], b = segment[1];
      console.log("for " + (ind + 1) + " segment:");
      printFinal("division by half", halfDiv(a, b));
      printFinal("chord method", chordMet(a, b));
      printFinal("newton method", newtMet(a, b));
      printFinal("modified newton method", modNewtMet(a, b));
    }
    getDataArray = function(f, a, b, step) {
      var dataArray, x;
      dataArray = [['x', 'y']];
      x = a;
      while (x <= b) {
        dataArray.push([x, f(x)]);
        x += step;
      }
      return dataArray;
    };
    drawChart = function() {
      var chart, data, dataArray, options;
      dataArray = getDataArray(f, a - 2, b + 2, e);
      data = google.visualization.arrayToDataTable(dataArray);
      options = {
        title: funStr,
        curveType: 'function',
        legend: {
          position: 'bottom'
        },
        height: 1000
      };
      chart = new google.visualization.LineChart(document.getElementById('chart'));
      chart.draw(data, options);
    };
    google.charts.load('current', {
      'packages': ['corechart']
    });
    return google.charts.setOnLoadCallback(drawChart);
  });

}).call(this);
